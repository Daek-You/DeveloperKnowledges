## 1. 비트마스킹(Bitmasking)이란?

- 정수의 2진수 표현을 자료구조로 사용하는 기법
- 컴퓨터가 처리하는 연산과 가깝기 때문에 실행 속도가 빠르고, 메모리를 적게 사용함
- 프로그래밍 언어에서 주로 지원하는 비트 관련 연산은 다음과 같이 존재

| 식     | 의미                                                         |
| ------ | ------------------------------------------------------------ |
| a & b  | - AND 연산<br>- 둘 다 true라면 true, 아니라면 false          |
| a \| b | - OR 연산<br>- 둘 다 false라면 false, 아니라면 true          |
| a ^ b  | - XOR 연산<br>- 둘이 다르다면 true, 같다면 false             |
| ~a     | - NOT 연산<br>- false면 true, true면 false                   |
| a << b | - 왼쪽 쉬프트(Shift) 연산<br>- a를 b비트만큼 왼쪽으로 시프트 |
| a >> b       | - 오른쪽 쉬프트(Shift) 연산<br>- a를 b비트만큼 오른쪽으로 시프트                                                             |

<br>

## 2. 비트마스킹의 활용 : "집합"

### 1) 집합의 표현 방법
- N개의 원소를 가진 집합에서, 각 원소의 번호를 0 ~ N - 1번으로 지정
- 해당 번호의 원소가 존재한다면 1, 아니라면 0으로 표현할 수 있음

> 집합 `{A, B, C, D, E ,F, G}`에서 만약 C, D, E 원소만 존재한다면 `0011100`로 표현

<br>

### 2) 집합의 연산

- 현재 상태 `current`가 있고, `i`번째에 원소를 추가한다고 하면 다음과 같이 할 수 있다.

```cpp
current |= (1 << i);
```  

- AND와 NOT 연산을 활용하여, i번째 원소를 삭제할 수 있다.  

```cpp
current &= ~(1 << i);
```  

- 다음 연산을 통해, 집합 내에 i번 원소가 포함되어 있는지 확인할 수 있다.

```cpp
if (current & (1 << i))
{
	// ...
}
```  

- i번째 원소에 대해 토글을 적용하고 싶다면, XOR 연산을 활용할 수 있다.

```cpp
current ^= (1 << i);
```  

- 원소의 개수가 `N`개일 때, 다음 연산을 통해 공집합 혹은 꽉 찬 집합을 구할 수 있다.

```cpp
current = 0;           // 공집합
current (1 << N) - 1;  // 꽉 찬 집합
```  

- 1의 개수를 다 세어봄으로써, 집합의 크기를 구할 수 있다.

```cpp
int BitCount(int x)
{
	if (x == 0)
		return 0;
	return x % 2 + BitCount(x / 2);
}
```  

- 주어진 집합의 모든 부분 집합 순회는 다음과 같이 할 수 있다.

```cpp
for (int subset = set; subset; subset = (subset - 1) & set)
{
	// ...
}
```  




