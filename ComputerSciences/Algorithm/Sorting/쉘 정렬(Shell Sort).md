## 1. 쉘 정렬(Shell Sort)이란?
- [**삽입 정렬**](삽입%20정렬(Insertion%20Sort).md)의 문제점을 보완한 알고리즘  
    > - 삽입 정렬은 데이터가 삽입될 때, 이웃한 위치로만 데이터가 이동 가능  
    > - 만약 가장 작은 원소가 마지막 순서에 저장될 경우?  👉🏻  $n-1$ 번의 교환 연산이 발생  
    >   👉🏻 **정렬 시간이 오래 걸리게 되는 이유**  
    > - 즉, 현재 데이터가 삽입되는 위치와 올바른 위치가 먼 경우에는 많은 교환 연산이 발생하게 됨  

- 쉘 정렬은 **데이터 간 교환 거리를 1이 아닌 `h` 만큼 늘린 후, 점차적으로 줄여가며 삽입 정렬**을 하는 방식
- `h` 간격마다 존재하는 데이터들끼리 그룹을 형성하고, 해당 그룹 내에서 삽입 정렬을 실시
- `h`를 점차 줄이면서 삽입 정렬을 하다 보면, 부분적으로 정렬이 완료된 리스트들이 생성될 것임
    - 삽입 정렬이 가장 좋은 성능을 내는 순간이 **정렬되어 있는 경우**이므로, 성능 향상
- $h=1$이 될 때까지 삽입 정렬을 진행  👉🏻  $h=1$이라면, 일반적인 삽입 정렬과 같음  
<br>

### 예제 시나리오
[**🔗사진 출처**](https://velog.io/@roro/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%85%B8%EC%A0%95%EB%A0%AC)  
<br>

1. 초기 **`[8, 1, 4, 2, 7, 6, 3, 5]`** 배열에서 $h=4$ 로 쉘 정렬을 처음 시작  
    
    ![1회](https://user-images.githubusercontent.com/39042837/110901639-fae28d00-8347-11eb-9bc2-d7fe6eac6900.jpeg)  
2. 1번에서 정렬된 **`[7, 1, 3, 2, 8, 6, 4, 5]`** 에서 $h=2$ 로 쉘 정렬을 진행  

	![2회](https://user-images.githubusercontent.com/39042837/110901649-fd44e700-8347-11eb-85f6-c33cdba4974d.jpeg)  

3. 다음은 $h=1$이므로, 그냥 일반 삽입 정렬을 실시  👉🏻  `[1, 2, 3, 4, 5, 6, 7, 8]`  
<br>

## 2. 쉘 정렬의 알고리즘
### 알고리즘
1. $h_r, \ h_{r-1}, ..., \ h_1$ 까지의 수열을 가정한다.  ($h_1 = 1, \ h_{i-1} < h_i$)  
2. 처음에는 $h_r$ 개 떨어진 원소들 간에 삽입 정렬을 실시  
3. 이후에는 $h_{r-1}$ 부터 $h_1$ 까지 $h$ 를 줄이면서 삽입 정렬을 실시  
    - $h_1$ 의 경우에는 일반적인 삽입 정렬과 같음  

### 특성
- $h$ **값이 클 경우 (초기 단계)**  👉🏻  리스트의 길이가 짧음 (간격이 크니까 당연한 얘기)
- $h$ **값이 작을 경우 (끝 단계)**  👉🏻  리스트는 부분적으로 정렬된 상태 (삽입 정렬을 실시해 왔으니)  

### $h$ 수열은 어떻게 할당하는 게 좋은가?
- $h_1=1$이므로, 어떤 값을 할당하더라도 마지막 단계에서 정렬은 실시됨
- **수열 길이가 길다면?  👉🏻  작업 단계 수 증가**
- **수열 길이가 짧다면?  👉🏻  성능 향상 정도가 미약**
- 최선의 수열은 아직까지 발견되지 않고 있음
- 일반적으로 $h_i = 3 \times h_{i-1} + 1$ 의 수열을 많이 사용  →  평균 $\mathrm{O(n^{1.5})}$  
<br>

## 3. C++로 구현한 쉘 정렬
```cpp
#include <vector>
using namespace std;

// 조금 변경된 삽입 정렬 함수
// 기존에 1만큼 건너뛰던 것에서 h만큼 건너뛰는 것으로 변경
void InsertionSort(vector<int>& arr, int currentIdx, int h)
{
    int n = arr.size();
    int key = arr[currentIdx];
    int previous = currentIdx - h;

    while ((previous >= 0) and (arr[previous] > key))
    {
        arr[previous + h] = arr[previous];
        previous -= h;
    }

    arr[previous + h] = key;
}

void ShellSort(vector<int>& arr)
{
    int n = arr.size(), h = 1;

    while (h < n / 3)
        h = 3 * h + 1;    // h 수열 : [1, 4, 13, 40, 121, 364, 1093, ...]

    while (h >= 1)
    {
        for (int i = h; i < n; i++)
            InsertionSort(arr, i, h);
        h /= 3;
    }
}
```  
<br>

## 4. 쉘 정렬의 성능 분석
### 장점
- 연속적이지 않은 부분 리스트에서 데이터 교환이 일어나면 더 큰 거리를 이동
    - 따라서, 교환되는 데이터들이 삽입 정렬보다는 최종 위치에 있을 확률이 더 높아짐
- **`부분 리스트`** 는 **어느 정도 정렬된 상태**가 됨
  👉🏻 $h=1$ 일 때, 삽입 정렬을 시도하더라도 최고의 성능을 낼 수 있음
- 알고리즘이 간단하여 쉽게 구현이 가능  

### 시간 복잡도
- 최선 : $\mathrm{O(n)}$
- 평균 : $\mathrm{O(n^{1.5})}$
- 최악 : $\mathrm{O(n^2)}$