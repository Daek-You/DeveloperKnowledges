#CLR #ManagedCode #UnmanagedCode #JIT #JIT_Compiler #CIL
# Managed Code
> [!check]  **`CLR(Common Language Runtime)`** 에 의해 실행이 제어되는 코드  

- CLR에 의해 자동으로 코드에 가비지 수집, 유형 검사, 예외 처리, 경계 검사, 메모리 할당, 유형 안전성 등과 같은 다양한 서비스를 제공 받을 수 있음
- 프로그래머가 위와 같은 내용에 대해 신경 쓸 필요가 없다는 장점이 있음
- C#, Visual Basic 등과 같은 .NET 위에서 실행될 수 있는 고급 언어 중 하나로 작성됨
- 각 언어 컴파일러가 `Managed code`를 컴파일 할 경우, 기계어로 변환하지 않음
- 그 대신, `CIL(Common Intermediate Language)`로 변환

#### 장점  
- 런타임 환경을 사용할 때처럼 애플리케이션의 보안을 향상시키며, 메모리 버퍼를 자동으로 확인하여 버퍼 오버플로를 방지
- Garbage Collection을 자동으로 구현
- 런타임 유형 검사/동적 유형 검사 제공
- 참조 확인 기능도 제공
	- 즉, 참조 지점이 유효한 개체인지 여부를 확인하고 중복되지 않는지 확인

#### 단점  
- 메모리를 직접 할당할 수 없다.
- CPU Architecture에 대한 Low-Level 접근을 얻을 수 없다.
<br>

## Common Intermediate Language

> [!check] `.NET High-Level 언어로 작성된 Managed code`를 컴파일 한 산출물  

![JIT Compile](https://media.geeksforgeeks.org/wp-content/uploads/20190410185504/Working-of-JIT-Compiler1.png)

- `CPU가 실행할 수 있는 코드(Native code)`로 효율적으로 변환이 가능하며, CPU와 OS에 독립적
- 그렇기에, 특정 컴퓨터에 종속되지 않고 CLR이 설치된 모든 플랫폼에서 실행이 가능
> [!tip] CIL의 구성 요소
> CIL에는 `오브젝트에 대한 메서드 로드`, `저장`, `초기화 및 호출`에 대한 명령어 뿐만 아니라 `산술 및 논리 연산`, `제어 흐름`, `메모리 직접 접근`, `예외 처리 및 기타` 등에 대한 명령어도 포함되어 있습니다.  

- CIL 생성 시, 코드 유형의 정의 및 서명과 런타임 정보 등이 들어 있는 `메타데이터(Metadata)`도 생성  
> [!tip] 메타데이터(Metadata)  
> 각 타입의 정의, 멤버의 시그니처, 코드가 참조하는 멤버, CLR이 실행 시 사용하는 기타 데이터를 포함하여 코드의 타입을 설명하는 데이터입니다. 메타데이터는 CIL과 함께 저장되며, 로드 및 이식이 가능한 모든 CLR 파일에는 메타데이터가 포함되어 있습니다. 
> 
> CLR은 실행 중에 필요에 따라 이러한 메타데이터를 찾아 클래스를 로드하고, 메모리에 인스턴스를 배치하고, 메소드를 호출하고, 네이티브 코드(native code)를 생성하며, 보안을 강화하고, Runtime Context 경계를 설정할 수 있는 이러한 모든 서비스를 제공할 수 있게 됩니다.

- CLR은 이러한 CIL에 대해 `JIT(Just-In-Time) 컴파일`을 진행하여 실행되는 컴퓨터 환경과 관련된 기계어로 변환함
<br>

## JIT(Just-In-Time) Compiler
> [!check] `CLR의 일부`로서, `CIL 코드`를 구동 중인 컴퓨터 환경에 맞는 `기계어 코드`로 변환하는 역할을 담당  

- JIT 컴파일러는 요구 사항에 따라 CIL 전체가 아닌, 필요에 따라 컴파일을 진행하게 됨
- 이렇게 JIT 컴파일러에 의해 얻은 기계어는 CPU에 의해 실행
- 필요한 경우, 컴파일 된 CIL은 후속 호출에서 사용할 수 있도록 저장됨

#### 장점
- 런타임에 필요한 메서드만 컴파일하므로, 메모리 사용량이 적음
- 페이지 폴트(Page fault)가 줄어듦  👉🏻  필요한 메서드가 동일한 메모리 페이지에 있을 확률이 높기 때문
- 통계 분석을 기반으로 한 코드 최적화는 코드가 실행되는 동안 JIT 컴파일러에서 수행 가능

#### 단점
- 애플리케이션이 처음 실행되는 동안, 더 많은 시작 시간이 필요
- 캐쉬 메모리를 JIT 컴파일러에서 많이 사용함  👉🏻  런타임에 필요한 소스 코드 메서드를 JIT 컴파일러에서 많이 저장하기 때문
<br>

---
# Unmanaged Code
> [!check] 운영 체제에서 직접 실행되는 코드  

- Managed code처럼 CIL로 변환되는 과정이 없음
- 이에 따라, 다른 아키텍처에 대해 동일한 코드를 실행하려면 다시 컴파일 과정 필요
- Managed code와 달리, 메모리 할당, 유형 안전성, 보안 등을 개발자가 직접 관리
	- 이로 인해 버퍼 오버플로우, 메모리 누수, 포인터 재정의 등과 같은 메모리 관련 문제 가 발생
- Unmanaged code의 실행 파일은 일반적으로 메모리에 직접 로드되는 x86 Binary image
- VB 6.0, C, C++ 등으로 작성된 애플리케이션은 항상 Unmanaged code로 되어 있음

#### 장점
- 프로그래머에게 Low-Level 접근을 제공
- 하드웨어에 대한 직접적인 접근도 제공
- 이를 통해, 프로그래머는 Managed Code Framework에서 사용되는 일부 매개 변수와 제한 사항을 우회 가능

#### 단점
- 애플리케이션에 보안이 제공되지 않음
- 메모리 할당에 대한 접근으로 인해, 메모리 버퍼 오버플로우 등과 같은 메모리 관련 문제 발생
- 오류와 예외 처리도 프로그래머가 직접 처리해야 함
- 가비지 수집에 중점을 두지 않음