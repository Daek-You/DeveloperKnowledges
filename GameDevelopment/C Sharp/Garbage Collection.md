# Garbage Collector

- `.NET Garbage Collector`는 애플리케이션의 메모리 할당 해제를 관리
- 새 오브젝트를 만들 때마다, [CLR](CLR%20(Common%20Language%20Runtime).md) 은 `Managed Heap`에서 해당 오브젝트에 대한 메모리를 할당
- `Managed Heap` 메모리 공간을 사용할 수 있는 한, `CLR`은 `Managed Heap` 새 오브젝트에 대한 메모리를 할당
- 하지만 언젠가는 `Managed Heap` 메모리 공간이 꽉 찰 것이기에, `Garbage Collector`는 일부 메모리를 해제하기 위해 수집을 개시해야 함
- `Garbage Collector의 최적화 엔진`은 수행 중인 할당에 따라, 가비지를 수집 할 최적의 시간대를 결정
	1. 시스템의 메모리가 부족 (GC를 실행하는데는 충분하나 곧 할당이 실패되는 시점)
	2. 메모리 단편화가 심해졌을 때(Compaction)
	3. 매량의 메모리를 할당했을 때(GC 이후에 1MB를 할당시 GC를 실행 함)  

<br>

## 세대별 가비지 컬렉션

- CLR은 메모리 구역을 나누어 빨리 해제 될 객체와 오래 남을 것 같은 객체를 따로 관리. 이를 3개의 세대(0, 1, 2)로 나누어 관리하게 됨.
	- `0 세대` : 가비지 컬렉션을 한 번도 겪지 않은 "갓 생성된" 객체
	- `1 세대` : 0세대에서 2세대로 넘어가는 과도기의 객체
	- `2 세대` : 최소 2회 이상 가비지 컬렉션을 겪고도 살아남은, 산전수전 다 겪은 객체
- 가비지 컬렉션 빈도는 2세대 < 1세대 < 0세대
<br>

1. 처음 오브젝트를 Managed Heap에 할당하게 되면, 0세대로 등록됨  
	- 오브젝트를 계속 할당하다 보면, 언젠가 0세대 오브젝트들의 총 크기가 `0세대 가비지 컬렉션 임계치`에 도달할 것  
	- 이 때, 0세대에 대해 가비지 컬렉션 작업을 수행  
	- 여기서 살아남은 객체들은 1세대로 옮겨지게 됨  
2. 1번 과정을 계속 거치다 보면, 1세대에도 가비지 컬렉션 임계치에 도달하는 순간이 올 것임  
	- 이 때, 가비지 컬렉터는 `하위 세대에 대해서도 컬렉션 작업을 수행`하기 때문에 0세대에 대해서도 가비지 컬렉션 작업을 수행  
	- 1세대 가비지 컬렉션에서 살아남은 객체는 2세대로 옮겨지게 됨  

> [!warning] Full GC
> - 2세대 힙이 가득차는 경우 수행됨
> - CLR에서 애플리케이션 실행을 일시 중단함
> - 0 ~ 2세대 전체 메모리에 걸쳐 가비지를 수집
> - 애플리케이션이 차지하는 메모리가 클수록 장시간 실행이 중지됨  


<br>

## SOH와 LOH 개념
#### SOH (Small Object Heap)
- 용량이 85KB 미만인 작은 객체
- 세대별 GC 방식이 그대로 적용됨
#### LOH (Large Object Heap)
- 용량이 85KB 이상인 큰 객체 (`2세대 힙`으로 간주)
- 할당 시의 성능과 메모리 공간 효율이 좋지 않음  

<br>

# Garbage 선정 방법
### Mark and Sweep 알고리즘

- 모든 참조 오브젝트는 생성 시, 자동적으로 GC에 등록됨
- 이때, 내부적으로 **`marked`** 라는 플래그가 존재하며, 초깃값은 `false`
- 전역 변수, 현재 함수의 로컬 변수를 통한 참조를 **`루트(Root)`** 라고 부른다.
	- 즉, 외부에서 들어오는 참조가 없는 것
- Mark and Sweep 알고리즘은 Mark 단계, Sweep 단계, Compaction 단계로 나뉘어져 진행된다.

#### 1. Mark 단계
- 모든 참조 오브젝트들의 **`marked`** 를 `false`로 지정한다.
- 루트를 기반으로 참조를 타고 순회를 하며, 방문한 객체의 **`marked`** 를 `true`로 지정한다.
- 모든 순회가 끝났다면, Sweep 단계로 진입한다.  

#### 2. Sweep 단계
- **`marked`** 가 `false`인 참조 오브젝트들은 사용되지 않는 가비지라고 판단
- **`Managed Heap`** 의 전체 메모리를 순회하며, 가비지들을 모두 메모리에서 해제
- 또한, 순회하는 과정에서 가비지가 아닌 참조 오브젝트들의 **`marked`** 를 다시 `false`로 변경하여, 후속 GC가 잘 작동하도록 세팅  

#### 3. Compaction 단계
- 메모리 단편화가 생길 수 있으므로, **`Compaction`** 작업을 추가로 진행
- 참조 오브젝트들의 주소가 변경되고, 이를 가리키는 변수들의 값을 모두 업데이트 해줘야 하므로 매우 무거운 작업