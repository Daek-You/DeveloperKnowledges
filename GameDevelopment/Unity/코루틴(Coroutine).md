[이거 보고 더 정리하자](https://medium.com/supercent-blog/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EA%B8%B0%EB%B3%B8%EA%B8%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-coroutine-5048334a2e2f)  

## 코루틴(Coroutine)
- 일반 메서드와 달리, **작업을 여러 프레임에 걸쳐 실행할 수 있는 특별한 메서드**  

> [!check] 코루틴의 사용 예  
> - 시간의 흐름에 따른 이벤트의 절차
> - [절차적 애니메이션(Procedural Animation)](https://kangworld.tistory.com/187)  
> - HTTP 전송, 에셋 로드, 파일 I/O 완료 등과 같이 긴 비동기 작업을 처리할 경우  

> [!tip] 일반 메서드  
> 일반 메서드는 호출 시, 실행을 완료하면 호출한 메서드에게 제어권과 리턴 값을 반환해주는 형태(void 형 메서드는 반환이 없음)이며, **단일 프레임 내에서 모든 작업이 이루어진다.**  

- 코루틴은 스레드가 아니며, **`메인 스레드`** 에서 동작
- 실행하다가 일시 정지 후 Unity에게 제어권을 반환하는 형식
- 다음 프레임에서 중단한 부분부터 실행 가능
- 모든 프레임에서 호출하기 부담스러운 메서드 같은 경우, 코루틴을 통해 주기를 늘려서 호출하도록 하여 부담 완화 가능


### Invoke와의 차이점
```c#
// MonoBehaviour.Invoke
public void Invoke(string methodName, float time);
```
- Invoke는 주어진 메서드를 초 단위로 지연시켜 호출할 수 있다.
- 매우 간편한 방식으로 함수를 지연시켜 호출할 수 있다는 장점이 있다.
- 문자열로 받은 메서드 이름을 런타임 중에 리플렉션을 통해 찾기에, 코루틴보다 느리다는 단점이 있다.
- 매개변수 인자를 줄 수 없다는 단점도 존재.

#### Coroutine
