## 코루틴(Coroutine)
- 일반 메서드와 달리, **작업을 여러 프레임에 걸쳐 실행할 수 있는 특별한 메서드**  

> [!check] 코루틴의 사용 예  
> - 시간의 흐름에 따른 이벤트의 절차
> - [절차적 애니메이션(Procedural Animation)](https://kangworld.tistory.com/187)  
> - HTTP 전송, 에셋 로드, 파일 I/O 완료 등과 같이 긴 비동기 작업을 처리할 경우  

> [!tip] 일반 메서드  
> 일반 메서드는 호출 시, 실행을 완료하면 호출한 메서드에게 제어권과 리턴 값을 반환해주는 형태(void 형 메서드는 반환이 없음)이며, **단일 프레임 내에서 모든 작업이 이루어진다.**  

- 코루틴은 스레드가 아니며, **`메인 스레드`** 에서 동작
- 실행하다가 일시 정지 후 Unity에게 제어권을 반환하는 형식
- 다음 프레임에서 중단한 부분부터 실행 가능
- 모든 프레임에서 호출하기 부담스러운 메서드 같은 경우, 코루틴을 통해 주기를 늘려서 호출하도록 하여 부담 완화 가능

### 코루틴의 특징

- 반드시 **`IEnuemrator`** 를 반환
- **`yield return`** 을 만나는 구간마다, 다음 구문이 실행되는 프레임으로 나뉘게 됨
- **`yield break`** 를 만나면, 바로 코루틴이 종료
- 코루틴 실행을 위해선, **`MonoBehaviour`** 를 상속 받는 객체 필요
	- 코루틴을 다루는 메서드들은 모두 **`MonoBehaviour`** 클래스에 구현되어 있음
- 코루틴에는 **`소유권`** 이라는 개념이 존재
	- **`StartCoroutine()`** 을 실행한 객체가 해당 코루틴에 대한 소유권을 가짐
	- 소유권을 가진 객체가 비활성화되거나 파괴되면, 해당 객체가 소유한 모든 코루틴은 중단
	- 비활성화된 객체에 코루틴 시작을 요청해도 해당 코루틴은 실행되지 않음  

### 코루틴의 동작 원리

- 유니티는 C#에서 제공하는 **`반복자(Iterator)`** 를 활용해, 코루틴 시스템을 제공
	- 한 단계가 진행될 때마다 다음 프레임에서 실행되도록 구현
	- 이러한 기능을 구현하기 위해, 유니티 내부에는 **`DelayedCallManager`** 라는 클래스가 존재

#### DelayedCallManager

- 코루틴 실행 시, **`첫 번째 yield return`** 구문을 만나기 전까진 일반 메서드와 동일하게 실행됨
- **`첫 번째 yield return`** 구문을 만나면, 해당 코루틴은 **`DelayedCallManager`** 에 등록됨
- 따라서, **`DelayedCallManager` 에 등록된 이후 프레임부터** 코루틴이 진행되는 것
	- 코루틴이 실행되고 있는 위치를 찾는 데에 도움이 되는 가장 핵심 지식!	
