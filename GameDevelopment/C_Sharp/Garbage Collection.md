- `.NET Garbage Collector`는 애플리케이션의 메모리 할당 해제를 관리
- 새 오브젝트를 만들 때마다, [CLR](obsidian://open?vault=MyNote&file=%EC%A7%80%EC%86%8D%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EA%B4%80%EB%A6%AC%2FC%20sharp%20Topics%2FCLR%20(Common%20Language%20Runtime))은 `Managed Heap`에서 해당 오브젝트에 대한 메모리를 할당
- `Managed Heap` 메모리 공간을 사용할 수 있는 한, `CLR`은 `Managed Heap` 새 오브젝트에 대한 메모리를 할당
- 하지만 언젠가는 `Managed Heap` 메모리 공간이 꽉 찰 것이기에, `Garbage Collector`는 일부 메모리를 해제하기 위해 수집을 개시해야 함
- `Garbage Collector의 최적화 엔진`은 수행 중인 할당에 따라, 가비지를 수집 할 최적의 시간대를 결정
	- `Managed Heap`에서 **더 이상 사용되지 않는 오브젝트**를 확인하고, 해당 메모리를 회수하는 데에 필요한 작업을 진행
<br>

## 세대별 가비지 컬렉션
- CLR은 메모리 구역을 나누어 빨리 해제 될 객체와 오래 남을 것 같은 객체를 따로 관리. 이를 3개의 세대(0, 1, 2)로 나누어 관리하게 됨.
	- `0 세대` : 가비지 컬렉션을 한 번도 겪지 않은 "갓 생성된" 객체
	- `1 세대` : 0세대에서 2세대로 넘어가는 과도기의 객체
	- `2 세대` : 최소 2회 이상 가비지 컬렉션을 겪고도 살아남은, 산전수전 다 겪은 객체
- 가비지 컬렉션 빈도는 2세대 < 1세대 < 0세대
<br>
1. 처음 오브젝트를 Managed Heap에 할당하게 되면, 0세대로 등록됨
	- 오브젝트를 계속 할당하다 보면, 언젠가 0세대 오브젝트들의 총 크기가 `0세대 가비지 컬렉션 임계치`에 도달할 것.
	- 이 때, 0세대에 대해 가비지 컬렉션 작업을 수행
	- 여기서 살아남은 객체들은 1세대로 옮겨지게 됨
2. 1번 과정을 계속 거치다 보면, 1세대에도 가비지 컬렉션 임계치에 도달하는 순간이 올 것임.
	- 이 때, 가비지 컬렉터는 `하위 세대에 대해서도 컬렉션 작업을 수행`하기 때문에 0세대에 대해서도 가비지 컬렉션 작업을 수행
	- 1세대 가비지 컬렉션에서 살아남은 객체는 2세대로 옮겨지게 됨

> [!warning] Full GC
> - 2세대 힙이 가득차는 경우 수행됨
> - CLR에서 애플리케이션 실행을 일시 중단함
> - 0 ~ 2세대 전체 메모리에 걸쳐 가비지를 수집
> - 애플리케이션이 차지하는 메모리가 클수록 장시간 실행이 중지됨  
<br>

## SOH와 LOH 개념
#### SOH (Small Object Heap)
- 용량이 85KB 미만인 작은 객체
- 세대별 GC 방식이 그대로 적용됨

#### LOH (Large Object Heap)
- 용량이 85KB 이상인 큰 객체 (`2세대 힙`으로 간주)
- 할당 시의 성능과 메모리 공간 효율이 좋지 않음