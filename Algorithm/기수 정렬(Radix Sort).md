# 기수 정렬(Radix Sort)  

> **목차**  
> 1. [기수 정렬이란?](#1-기수-정렬radix-sort이란)  
> 1.1. [기수 정렬의 정렬 규칙](#11-기수-정렬의-정렬-규칙)  
> 2. [기수 정렬의 알고리즘](#2-기수-정렬의-알고리즘)  
> 2.1. [높은 자리 우선 정렬법](#21-높은-자리-우선-정렬-방법msd-sort)  
> 2.2. [낮은 자리 우선 정렬법](#22-낮은-자리-우선-정렬-방법lsd-sort)  
> 3. [낮은 자리 우선 정렬 방법 동작 과정](#3-낮은-자리-우선-정렬lsd-sort의-동작-과정)  
> 4. [C++로 구현한 LSD sort](#4-c로-구현한-lsd-기수-정렬)  
> 5. [기수 정렬의 성능 분석](#5-기수-정렬의-성능-분석)  

<br>

## 1. 기수 정렬(Radix Sort)이란?
- `키(key)`가 `d`개의 요소들로 구성된다면?  
    > ex) 주어진 키들이 모두 세 자리 숫자  
    > ex) 트럼프 카드 (무늬, 숫자라는 2가지 요소로 이루어짐)  
- 버킷 정렬처럼 `버킷(Bucket)`을 사용하나, 사전순 정렬이 가능한 정렬 기준이 있어야 함
- 이러한 특성을 이용하여, `자릿수`에 기반한 정렬 방식이 바로 기수 정렬(Radix Sort)  
- **크기가 유한하고, 사전순으로 정렬할 수 있어야 사용 가능**  

### 1.1. 기수 정렬의 정렬 규칙
1. 높은 자리의 요소가 우선순위를 높게 가진다.
2. 높은 자리가 동일할 경우, 그 다음 낮은 자리를 비교한다.  
> [Example] 트럼프 카드  
> 1. `무늬(높은 자리)`  → `🍀 < ♥️ < 💎 < ♠️`  
> 2. `숫자(낮은 자리)`  → `2 < 3 < ... < J < Q < K < A`  
> 👉🏻 정렬 순서 : `[ 2🍀, 3🍀, ..., A🍀, ..., 2♠️, ..., A♠️ ]`  

<br>

## 2. 기수 정렬의 알고리즘  
### 2.1. 높은 자리 우선 정렬 방법(MSD Sort)  
- 높은 자리 → 낮은 자리 순서
- 각 요소를 정렬 기준으로 하여 각 버킷 마다 정렬
- 사실상 버킷 정렬과 거의 유사
- 허나, `낮은 자리 우선 정렬(LSD sort)`를 사용하면 버킷별로 별도 정렬이 필요 없기에 `MSD Sort`는 잘 사용되지 않음  

### 2.2. 낮은 자리 우선 정렬 방법(LSD Sort)
- 낮은 자리 → 높은 자리 순서
- 낮은 자리 요소부터 하나씩 정렬해 나가기에, 별도의 버킷 내부 정렬 과정이 필요 없음
- 높은 자리 요소에 대해 정렬을 시도할 땐, `Stable sorting` 알고리즘을 사용  

<br>

## 3. 낮은 자리 우선 정렬(LSD Sort)의 동작 과정
- `A = [179, 208, 306, 93, 859, 984, 55, 9, 271, 33]` 이라는 정수 배열이 있다고 가정
- 정수는 각 자릿수가 `0 ~ 9`로 이루어져 있으므로 10개의 `버킷`이 필요
- 또한, 매 자릿 수마다 정렬한 결과를 임시로 저장해 둘 `별도의 배열` 필요
- 이를 기반으로 `LSD Sort`를 진행하면 다음과 같이 동작한다.


> 1. 현재 자릿 수(시작은 일의 자리)를 기준으로, 각각 버킷 배열에 개수를 센다.  
> - 사실 이 아래부터는 [계수 정렬(Counting Sort)](계수%20정렬(Counting%20Sort).md)과 비슷하다.
> 2. 개수를 다 센 버킷 배열에 대해 누적합을 저장한다.  
> 3. 입력 배열을 뒤에서부터 읽어가며, 누적합 버킷 배열을 통해 읽은 데이터의 올바른 위치를 알아낸다.  
> 4. 해당 데이터를 임시 배열에 저장한다.  
> 5. 완성된 임시 배열의 값들을 원본 입력 배열에 저장한다.  
> 6. 제일 큰 자릿 수에 대해 완료할 때까지 자릿 수를 올려가며 1~5번을 반복한다.  

<br>

## 4. C++로 구현한 LSD 기수 정렬
```cpp
#include <vector>
#include <algorithm>
using namespace std;

void RadixSort(vector<int>& arr, int bucketSize = 10)
{
    int exp = 1, N = arr.size();
    vector<int> temp(N);        // 기수 정렬 결과를 저장할 임시 배열


    // 1. 가장 큰 수 검색 -> 이 수에 다라 총 자릿수가 결정됨
    int maxValue = *max_element(arr.begin(), arr.end());

    // 2. exp = 1이므로, 1의 자리부터 LSD 시작
    while (maxValue / exp > 0)
    {
        vector<int> buckets(bucketSize);

        /* ------- 이 아래부턴 계수 정렬(Counting Sort)과 비슷한 과정을 거침 ------- */
        // 3. 각 자릿수에 따라, 버킷 배열에 카운팅
        for (int i = 0; i < N; i++)
        {
            int placeValue = (arr[i] / exp) % bucketSize;
            buckets[placeValue]++;
        }

        // 4. 누적합
        for (int i = 1; i < bucketSize; i++)
            buckets[i] += buckets[i - 1];

        // 5. 카운팅을 이용하여 뒤에서부터 정렬 (stable)
        for (int i = N - 1; i >= 0; i--)
        {
            int placeValue = (arr[i] / exp) % bucketSize;
            int index = --buckets[placeValue];
            temp[index] = arr[i];
        }

        // 6. 현재 자릿수 정렬 결과를 원래 배열에 저장
        for (int i = 0; i < N; i++)
            arr[i] = temp[i];

        exp *= bucketSize;
    }
}
```  

<br>

## 5. 기수 정렬의 성능 분석
### 장점
- 적당한 도메인에서 최적화 된 기수 정렬은 매우 빠름
- 자릿수가 고정되어 있어서, 안정성(Stable)이 있는 정렬 방식
- 계수 정렬에 비해 약간 느리지만, 계수 정렬과 달리 숫자가 매우 큰 상황에서도 사용 가능  

### 단점
- 기수에 해당하는 크기만큼 추가 메모리가 요구됨
    - ex) 알파벳인 경우, 26개의 버킷이 필요  

### 시간 복잡도
- 데이터들의 최대 자릿수를 `D`, 기수의 도메인 크기를 `K`라고 가정  
    > 최댓값이 세 자리 수인 정수 배열을 예로 든다면, `D = 3`, `K = 10`(숫자는 0 ~ 9까지 총 10개이므로)  

- 총 데이터의 개수 `N`을 순회하면서 버킷 크기 `K`도 순회를 할 것이고, 이것을 `D`번 반복하므로 시간 복잡도는 $\mathrm{O(D \times (N + K))}$ 이 된다.



